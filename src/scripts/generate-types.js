const fs = require("fs");

const { pascalCase } = require("pascal-case");
const prettier = require("prettier");
const TypeWriter = require("@gimenete/type-writer");
const webhooks = require("@octokit/webhooks-definitions");

const signatures = [];
const eventEnums = [];
const tw = new TypeWriter();

const doNotEditThisFileDisclaimer = `
// DO NOT EDIT THIS FILE DIRECTLY
// make edits in scripts/generate-types.js
`;
const eventPayloadsVariable = "EventPayloads";
const eventNamesVariable = "EventNames";

const generatePayloadType = typeName => ({
  rootTypeName: typeName,
  namedKeyPaths: {
    [`${typeName}.repository`]: "PayloadRepository",
    // This prevents a naming colision between the payload of a `installation_repositories` event
    // and the `repositories` attribute of a `installation` event
    "WebhookPayloadInstallation.repositories":
      "WebhookPayloadInstallation_Repositories"
  }
});

const generateEventType = (event, typeName) => `
  public on (
    event: ${eventNamesVariable}.${event},
    callback: (event: ${eventPayloadsVariable}.WebhookEvent<${eventPayloadsVariable}.${typeName}>) => (Promise<void> | void)): void
`;

const generateEventEnum = (event, name, actions) => `
    const enum ${event} {
      Default = "${name}",
      ${actions
        .map(action => {
          return `${pascalCase(action)} = "${name}.${action}"`;
        })
        .join(",")}
    }
`;

webhooks.forEach(({ name, actions, examples }) => {
  if (!examples) {
    return;
  }

  const typeName = `WebhookPayload${pascalCase(name)}`;
  tw.add(examples, generatePayloadType(typeName));

  const event = `${pascalCase(name)}Event`;
  signatures.push(generateEventType(event, typeName));

  eventEnums.push(generateEventEnum(event, name, actions));
});

const generateFile = (filepath, content) => {
  const output = prettier.format(content, { filepath });
  fs.writeFileSync(filepath, output);
};

const definitionIndex = `
${doNotEditThisFileDisclaimer}

export { Webhooks } from './lib/generated/api'`;

generateFile("index.d.ts", definitionIndex);

const apiContent = `

import http = require('http');
import { ${eventNamesVariable} } from "./event-names";
import { ${eventPayloadsVariable} } from "./event-payloads";

type Options = {
  secret: string
  path?: string
  transform?: (event: ${eventPayloadsVariable}.WebhookEvent<any>) => ${eventPayloadsVariable}.WebhookEvent<any> & { [key: string]: any }
}

export declare class Webhooks {
  constructor (options?: Options)

  public on (event: ${eventNamesVariable}.ErrorEvent, callback: (event: Error) => void): void
  public on (event: '*' | string[], callback: (event: ${eventPayloadsVariable}.WebhookEvent<any>) => Promise<void> | void): void
  ${signatures.join("\n")}

  public sign (data: any): string
  public verify (eventPayload: any, signature: string): boolean
  public verifyAndReceive (options: { id: string, name: string, payload: any, signature: string }): Promise<void>
  public receive (options: { id: string, name: string, payload: any }): Promise<void>
  public removeListener (event: string | string[], callback: (event: ${eventPayloadsVariable}.WebhookEvent<any>) => void): void
  public removeListener (event: string | string[], callback: (event: ${eventPayloadsVariable}.WebhookEvent<any>) => Promise<void>): void
  public middleware (request: http.IncomingMessage, response: http.ServerResponse, next?: (err?: any) => void): void | Promise<void>
}
`;

generateFile("lib/generated/api.d.ts", apiContent);

const eventNamesContet = `
${doNotEditThisFileDisclaimer}

export namespace ${eventNamesVariable} {
  const enum ErrorEvent {
    Default = "error"
  }
  ${eventEnums.join("\n")}
}
`;

generateFile("lib/generated/event-names.d.ts", eventNamesContet);

const eventPayloadsContet = `
${doNotEditThisFileDisclaimer}

export namespace ${eventPayloadsVariable} {
  ${tw.generate("typescript", { inlined: false })}

  interface WebhookEvent<T> {
    id: string;
    name: string;
    payload: T;
    protocol?: "http" | "https";
    host?: string;
    url?: string;
  }
}
`;

generateFile("lib/generated/event-payloads.d.ts", eventPayloadsContet);
